/*
Esercizio c.1: L'incrocio fra una strada e un canale è regolato da un ponte mobile come quello illustrato
dall'apposito segnale.
Ovviamente le auto possono attraversare il ponte solo se è abbassato e si può alzare il ponte se non ci sono auto
che lo stanno attraversando. Il ponte deve essere alzato per far passare le imbarcazioni.
Il canale in corrispondenza del ponte ha una larghezza che consente il passaggio di una imbarcazione alla volta
(indipendentemente dalla direzione di provenienza) e le imbarcazioni in attesa di attraversare il ponte non
possono superarsi a vicenda (l'ordine di accesso al canale sotto al ponte è FIFO).
Le auto per attraversare il ponte usano il seguente protocollo:
bridge.car_enter(direction)
... attraversa il ponte
bridge.car_exit(direction)
Le imbarcazioni usano il protocollo:
bridge.boat_enter(direction)
... passa sotto al ponte
bridge.boat_exit(direction)
dove direction vale 0 o 1 per riconoscere le due diverse direzioni delle auto o delle imbarcazioni. Occorre scrivere la soluzione in modo
da evitare casi di starvation
*/

class bridge {
  condition libero, basso, alto;
  bool isFree, isDown;
  int numMacchine =0;
  Queue boat;
  
  void car_enter(direction){
    wait(basso);
    isDown = true;
    numMacchine ++;
    signal(car_exit);
   }
   
   void car_exit(direction){
    wait(car_exit);
    numMacchine--;
    
    if(numMacchine ==0){
      signal(alto);
     }
   }
   
   void boat_enter(direction){
	    if(isDown==true){
	     boat.enqueue(direction);
	     wait(alto);
	    }
	    while(boat.size() !=0){
	    isDown = false;
	     signal(boat_exit);
	   }
  }

void boat_exit(direction){
	wait(boat_exit);
	boat.dequeue(direction);
	if(boat.size() == 0){
	  signal(basso);
	}
}
}
   
    
    
    
