1. La libreria C fornisce delle funzioni che consentono di richiedere system call (per esempio open, read, ecc.). 
Come sono realizzate queste funzioni? Come vengono passati i parametri e il valore di ritorno delle system call?
I parametri sono in registri della CPU. 
In un altro registro di vede il valore della system call

2. Dati 4 dischi da 1GB, si possono memorizzare più dati usando una organizzazione RAID!= o RAID5? perché?
RAID5 memorizza 3 dischi, RAID10 solo 2.

3. Dimostrare che se un algoritmo di rimpiazzamento è a stack allora non può soffrire dell'anomalia di Belady.
Se è a stack per ogni frame se ne aggiugne 1, diventa un sottoinsieme. Non può mai avere page fault.

4. L'algoritmo del Banchiere evita che si verifichino situazioni di deadlock. Sembra una funzione desiderabile,
eppure viene raramente usato nei sistemi reali, perché?
I processi danno a priori la quantità massima di risorse da utilizzare.

5. quali operazioni compie un device driver per iniziare un'operazione di I/O? 
Come viene rilevato il completamento dell'operazione di I/O?

6. In un sistema a memoria virtuale un interrupt di tipo TLB-miss indica sempre la mancanza di una pagina
in memoria (page miss)?

7. Quali sono le metodologie che si possono utilizzare per minimizzare i rischi di attacco tramite worm?

8. confrontare l'allocazione concatenata e l'allocazione indicizzata nei file system. Quali sono i pro e 
i contro dei due metodi?

9. Quali sono gli interrupt hardware più frequenti e quali le trap (interrupt software) più frequenti?

10. A cosa serve il Translation Lookahead Buffer?

11. Quali problemi può porre l'implementazione di un Sistema Operativo con il supporto di memoria virtuale e di
controller di I/O di tipo DMA?

12. Qual è la complessità computazionale dell'algoritmo del banchiere monovaluta e quella del banchiere multivaluta?

13. Perché il compilatore C è scritto in C? Come si fa a compilare il compilatore C se per compilarlo occorre il compilatore
C?

14. Come si calcola la lunghezza massima di un file in un file system di tipo UNIX?

15. Fornire un elenco di incongruenze che possono venir rilevate dal fsck (file system check) applicato a file
system di tipo UNIX (e.g. ext2, bffs). Per ogni tipo di incongruenza indicare come viene riscontrata e con quali
operazioni il fsck può ripristinare la coerenza.

16. Perché un algoritmo di rimpiazzamento a stack non può essere soggetto ad anomalia di Belady?

17. Le password (criptate) nei sistemi UNIX moderni sono memorizzate in un file inaccessibile agli utenti (/etc/shadow).
Perché?

18. Nello scheduler di tipo Shortest Remaining TIme First (versione preemptive di STF: Shortest time first), il tempo
residuo può diventare negativo. Perché?

19. Quando si usano i dischi a stato solido i file system vengono configurati in modo da non aggiornare il tempo di
ultimo accesso ai file (noatime). Perché?

20. Perché può essere difficoltoso revocare le capability di accesso a risorse?

21. Qual è la differenza fra una funzione di libreria (e.g. sprintf) e una system call (e.g. write).

22. Come si calcola la lunghezza massima di un file in un FIle System tipo UNIX (bffs, ext2, minix ecc)?

23. Come si fa a risolvere una situazione di deadlock?

24. Perché è meglio la paginazione della compattazione di memoria?

25. Per implementare un servizio di autorizzazione di tipo capability è meglio usare crittografia simmetrica o crittografia
a chiave pubblica? perché? E' necessario usare un metodo specifico (crittografia simmetrica o crittografia a chiave
pubblica) o il servizio di autorizzazione potrebbe essere implementato con entrambi?

26. Perché viene usata la paginazione per implementare la memoria virtuale?

27. L'algoritmo del banchiere dato uno stato di allocazione delle risorse restituisce un valore binario: safe o non safe.
In quali casi il sistema operativo esegue l'algoritmo del banchiere? Cosa succede se il risultato è safe e cosa se il
risultato è non-safe?

28 Fornire esempi di file system con allocazione contigua, e spiegare perché sarebbe inefficiente usare altri metodi di
allocazione nei casi d'uso tipici di questi file system.

29. perché l'invenzione degli interrupt ha reso i sistemi operativi più efficienti?

30. Usando l'algoritmo di rimpiazzamento FIFO la stringa di riferimenti 1,2,3,4,1,2,5,1,2,3,4,5 genera più page
fault con una memoria di 4 frame di quanti ne vengano generati con una memoria di 3 frame (anomalia di Belady)
i) si generi una stringa di riferimenti che generi più page fault in una memoria di 5 frame rispetto ad una da 4 frame.
ii) si costruisca una regola generale per costruire stringhe di riferimenti che generino più page fault in una memoria di
n frame rispetto a quelli generati in una memoria da n - 1 frame 

31. Lo scheduler sceglie fra i processi ready quale porre in esecuzione. Ma cosa succede quando la coda dei processi
ready è vuota?

32. Quali vantaggi offre RAID5 rispetto a RAID1?

33. Se per effetto di un guasto o di un bug il numero di hard link di un i-node è errato, quali conseguenze possono
esserci?

34. Quali eventi causano la valutazione dell'algoritmo del banchiere? Cosa si fa se lo stato risulta unsafe e cosa invece se
è safe?

35. Perché il nome del file non è memorizzato all'interno dell'i-node nei file system tipo UNIX (e.g. ext2/3/4)?

36 Un bug di tipo buffer overflow consente ad un attaccante di spedire più dati di quelli che il buffer di ricezione può
contenere, tracimando così nelle aree di memoria di altre variabili. Come è stato possibile in tanti casi che venisse
spedito codice macchina e che il programma vittima dell'attacco lo eseguisse?

37 come fa l'allocazione gerarchica ad evitare che si possano verificare casi di deadlock?

38. Per rendere uno scheduler round-robin più pronto a servire i processi interattivi si decide di dimezzare la durata del
time slice. Quali effetti collaterali può avere la scelta?

39. perché DMA viene utilizzato per le unità di memoria secondaria (es dischi) e non per terminali?

40. cosa succede in un sistema operativo quando un processo utente tenta di eseguire una operazione
illegale (es. divisione per zero)? Lo standard POSIX (UNIX) cosa prevede in questo caso?

41.L'algoritmo di rimpiazzamento second chance (detto anche dell'orologio) è a stack? Perché viene
preferito a LRU?

42. Quali sono le caratteristiche negative dell'uso delle Access Control List per la memorizzazione delle
informazioni di autorizzazione

43.  perché una situazione di trashing si può risolvere sospendendo l'esecuzione di processi?

44. come fa il sistema operativo a sospendere i processi che sono in attesa del completamento di una
richiesta di I/O?

45. quale tipo di crittografia è necessaria per implementare un servizio di autorizzazione basato su
capability? perché? (NB la domanda non fa riferimento alle POSIX capability)

46. Perché con due dischi si preferisce usare RAID1 piuttosto che RAID5? (infatti RAID5 è definito con un
minimo di 3 dischi).

47. In un sistema ci sono 3 classi di risorse A, B, C e 4 processi p,q,r,s.
In un determinato istante le tre risorse della classe A sono assegnate a p (due risorse) e a s (1 risorsa), l'unica risorsa
della classe B è assegnata ad r mentre le due risorse della classe C sono assegnate a q ed a r. Sono pendenti le
seguenti richieste: p ed s richiedono una risorsa della classe C e q chiede una risorsa della classe A.
Lo stato così determinato è di deadock? Mostrare il procedimento usato per ottenere la risposta.

48.  perché uno scheduler round-robin può essere inadatto a gestire processi con I/O multimediale?

49. per risolvere un problema di trashing è necessario terminare forzatamente dei processi o è sufficiente bloccare
l'esecuzione di qualche processo e riattivarli successivamente? Perché?
50.  Con lo stesso numero di dischi, RAID1 o RAID5 consente di memorizzare più dati? Perché? Quale è più sicuro?
Perché?

51. Perché è difficile revocare una autorizzazione fornita tramite una capability?

52. perché uno scheduler round-robin può essere inadatto a gestire processi con I/O multimediale?
Uno scheduler round-robin inserisce un processo in attesa di una risorsa IO
in fondo alla coda dei processi ready una volta che esso viene sbloccato,
al fine di dare la possibilita' ad altri processi in attesa di compiere le
proprie azioni e per evitare starvation. Tuttavia, cosi' facendo, un processo
che esegue un alto numero di richieste IO come una applicazione multimediale,
potrebbe trovarsi troppo tempo in coda ad attendere l'esecuzioen di altri
processi (in particolare cio' si verifica in un sistema "affollato").

Una possibile soluzione a questa problematica e' inserire le applicazioni
con un alto numero di operazioni IO in una cosa di priorita' piu' alta per
dargli precedenza rispetto ad altre task che possono aspettare come demoni
in background o task ricorrenti (cronjob).

53.  per risolvere un problema di trashing è necessario terminare forzatamente dei processi o è sufficiente bloccare
l'esecuzione di qualche processo e riattivarli successivamente? Perché?
Per risolvere il trashing non e' _necessario_ uccidere forzatamente alcun
processo. Sicuramente l'eliminazione di un processo e la conseguente
liberazione di una determinata area di memoria risulterebbe in una veloce
soluzione al problema veloce.
Tuttavia, per uscire da una situazione di trashing, che si verifica qunado
molti processi accedeono ad indirizzi logici frequentemenete sparsi tra
memoria centrale e secondaria (generando innumerevoli page fault), e'
sufficiente mettere in pausa alcuni processi, in attesa che altri completino
la loro esecuzione e liberino aree di memoria dove i processi messi in pausa
potranno poi caricare i dati a loro necessari in memoria centrale.

54. Con lo stesso numero di dischi, RAID1 o RAID5 consente di memorizzare più dati? Perché? Quale è più sicuro?
Perché?
A partia' di dirschi RAID 5 consente di utilizzare una maggior quantita' di
spazio per memorizzare dati effettivi. Sia RAID1 che RAID5 possono tollerare
fino al fallimento di 1 disco in quanto utilizzano 1 bit di parita'. Tuttavia
RAID5 utilizza bit di parita' per riparare un eventuale strip di dati perso,
mentre RAID1 funziona duplicando ogni strip su piu' dischi. In questo modo
RAID5 lascia molto piu' spazio per memorizzare dati, mentre con RAID1 si ha
a disposizione sempre e comunque la meta' dello spazio fisicamente disponibile.
FORSE: Con RAID1 tuttavia, avendo i dati duplicati in tutto il pool di dischi
e' statisticamente piu' probabile che la rottura di due dischi non provochi la
perdita di alcun dato, mentre con RAID5 la rottura di piu' di un disco portera'
sicuramente a una qualche quantita' di dati distrutti.

55. Perché è difficile revolacre una autorizzazione fornita tramite una capability?

56. perché l'invenzione degli interrupt ha reso i sistemi operativi più efficienti?

57. ha senso utilizzare RAID 5 con due dischi?

58. in quali casi entra in funzione il paginatore in un sistema di memoria virtuale e quando viene richiamato l'algoritmo
di rimpiazzamento?

59. quali sono i vantaggi e quali gli svantaggi dell'utilizzo di librerie dinamiche?
