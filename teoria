1. La libreria C fornisce delle funzioni che consentono di richiedere system call (per esempio open, read, ecc.). 
Come sono realizzate queste funzioni? Come vengono passati i parametri e il valore di ritorno delle system call?
I parametri sono in registri della CPU. 
In un altro registro di vede il valore della system call

2. Dati 4 dischi da 1GB, si possono memorizzare più dati usando una organizzazione RAID!= o RAID5? perché?
RAID5 memorizza 3 dischi, RAID10 solo 2.

3. Dimostrare che se un algoritmo di rimpiazzamento è a stack allora non può soffrire dell'anomalia di Belady.
Se è a stack per ogni frame se ne aggiugne 1, diventa un sottoinsieme. Non può mai avere page fault.

4. L'algoritmo del Banchiere evita che si verifichino situazioni di deadlock. Sembra una funzione desiderabile,
eppure viene raramente usato nei sistemi reali, perché?
I processi danno a priori la quantità massima di risorse da utilizzare.

5. quali operazioni compie un device driver per iniziare un'operazione di I/O? 
Come viene rilevato il completamento dell'operazione di I/O?

6. In un sistema a memoria virtuale un interrupt di tipo TLB-miss indica sempre la mancanza di una pagina
in memoria (page miss)?

7. Quali sono le metodologie che si possono utilizzare per minimizzare i rischi di attacco tramite worm?

8. confrontare l'allocazione concatenata e l'allocazione indicizzata nei file system. Quali sono i pro e 
i contro dei due metodi?

9. Quali sono gli interrupt hardware più frequenti e quali le trap (interrupt software) più frequenti?

10. A cosa serve il Translation Lookahead Buffer?

11. Quali problemi può porre l'implementazione di un Sistema Operativo con il supporto di memoria virtuale e di
controller di I/O di tipo DMA?

12. Qual è la complessità computazionale dell'algoritmo del banchiere monovaluta e quella del banchiere multivaluta?

13. Perché il compilatore C è scritto in C? Come si fa a compilare il compilatore C se per compilarlo occorre il compilatore
C?

14. Come si calcola la lunghezza massima di un file in un file system di tipo UNIX?

15. Fornire un elenco di incongruenze che possono venir rilevate dal fsck (file system check) applicato a file
system di tipo UNIX (e.g. ext2, bffs). Per ogni tipo di incongruenza indicare come viene riscontrata e con quali
operazioni il fsck può ripristinare la coerenza.

16. Perché un algoritmo di rimpiazzamento a stack non può essere soggetto ad anomalia di Belady?

17. Le password (criptate) nei sistemi UNIX moderni sono memorizzate in un file inaccessibile agli utenti (/etc/shadow).
Perché?

18. Nello scheduler di tipo Shortest Remaining TIme First (versione preemptive di STF: Shortest time first), il tempo
residuo può diventare negativo. Perché?

19. Quando si usano i dischi a stato solido i file system vengono configurati in modo da non aggiornare il tempo di
ultimo accesso ai file (noatime). Perché?

20. Perché può essere difficoltoso revocare le capability di accesso a risorse?

21. Qual è la differenza fra una funzione di libreria (e.g. sprintf) e una system call (e.g. write).

22. Come si calcola la lunghezza massima di un file in un FIle System tipo UNIX (bffs, ext2, minix ecc)?

23. Come si fa a risolvere una situazione di deadlock?

24. Perché è meglio la paginazione della compattazione di memoria?

25. Per implementare un servizio di autorizzazione di tipo capability è meglio usare crittografia simmetrica o crittografia
a chiave pubblica? perché? E' necessario usare un metodo specifico (crittografia simmetrica o crittografia a chiave
pubblica) o il servizio di autorizzazione potrebbe essere implementato con entrambi?

26. Perché viene usata la paginazione per implementare la memoria virtuale?

27. L'algoritmo del banchiere dato uno stato di allocazione delle risorse restituisce un valore binario: safe o non safe.
In quali casi il sistema operativo esegue l'algoritmo del banchiere? Cosa succede se il risultato è safe e cosa se il
risultato è non-safe?

28 Fornire esempi di file system con allocazione contigua, e spiegare perché sarebbe inefficiente usare altri metodi di
allocazione nei casi d'uso tipici di questi file system.

29. perché l'invenzione degli interrupt ha reso i sistemi operativi più efficienti?
